# Verilog HDL Study Notes
1.
数字电路设计中，数字电路简单归纳为两种要素：线和器件。器件可简单归纳为组合逻辑器件（与或非门）和时序逻辑器件（寄存器锁存器 RAM等）
Verilog HDL 中有两类数据类型:线网数据类型和寄存器数据类型。线网类型表示构件间 的物理连线,而寄存器类型表示抽象的数据存储元件。

2
Verilog模型可以是实际电路的不同级别的抽象。抽象级别对应的模型类型有以下五种：
（1）系统级（system-level）用语言提供的高级结构能够实现待设计模块的外部性能的模型
（2）算法级（algorithm-level）用语言提供的高级结构能够实现算法运行的模型
（3）RTL级（register-transistor-logic-level）描述数据在寄存器之间的流动 和如何处理控制这些数据流动的模型
以上3种都属于行为描述，只有RTL级才与逻辑电路有明确的对应关系。
（4）门级（gate-level）面熟逻辑门及逻辑门之间连接的模型
（5）开关级（switch-level）描述器件中三极管和储存节点及他们之间连接的模型
如果只从行为和功能的角度来描述某一电路模块，就称为行为模块，如果从电路结构的角度来描述该电路模块，就称为结构模块。
系统级算法级RTL级属于行为级，门级属于结构级

3
3.1
module muxtwo(out,a,b,sl);
    input a,b,sl;
    output out;
    reg out;
        always @ (sl or a or b)
            if(! sl) out = a;
            else out = b;

endmodule
//逻辑行为描述
//二选一多路器 输出out与a还是b一致 取决于sl

3.2
module muxtwo(out,a,b,sl);
    input a,b,sl;
    output out;
    reg out;
    wire nsl,sela,selb;
        assign nsl = ~sl;//sl取反
        assign sela = a&nsl;
        assign selb = b&sl;
        assign out = sela|selb;

endmodule
//逻辑表达式来描述

3.3
module muxtwo(out,a,b,sl);
    input a,b,sl;
    output out;
        not    u1(nsl,sl);
        and #1 u2(sela,a,nsl);
        and #1 u3(selb,b,sl);
        or  #2 u4(out,sela,selb);
endmodule

通过计算机上运行的工具把3.1通过3.2的中间形式自动转换为3.3形式的模块，这个过程叫做综合（synthesis）

4测试
include "muxtwo.v"
    module t;
    reg ain,bin,select;
    reg clock;
    wire outw;

    initial //寄存器变量初始化为确定值
    begin
    ain = 0;
    bin = 0;
    select = 0;
    clock = 0;
    end

    always #50 clock = ~clock;
    //产生一个不断重复周期为100的时钟信号clock

    always @(posedge clock)
        begin
        #1ain = {%random} %2;
        #3bin = {%random} %2;
    end

    always #10000 select =! select;//产生选通信号
        muxtwo m (.out(outw),.a(ain),.b(bin),.sl(select));
        //.表示端口后边紧跟端口名，其名称需与muxtwo中定义的一样
        //括号内的信号名为与该端口连接的信号线名 但必须在t中定义

    endmodule

5
verilog程序包括4个主要部分：端口定义，I/O说明，内部信号声明和功能定义
（1）引用模块时其端口可以用”." 标明原模块是定义时规定的端口名 如
模块名（. 端口1名（连接信号1名) ,.端口2名（连接信号2名）…）;
myDesignMK M1(.sin(SerialIn),.pout(ParrallelOut),….);
M1是与myDesignMK完全一样的模块。mydesignMK已经在另一个模块中定义过，它有两个端口，即sin和pout。与sin口连接的信号名为SerialIn，与pout端口连接的是信号名为ParallelOut
新模块名(.老端口名(新模块端口名))；
输入口：input[信号位宽-1 : 0] 端口名1；
输出口：ouput, 输入输出口：inout
（2）内部信号说明
reg[width-1 : 0]
wire[width -1 : 0]
(3) 逻辑功能定义
always 既可以用作描述组合逻辑，又可以描述时序逻辑

- 用assign, e.g. assign a = b & c;
- 实例元件 and #2 u1 (q,a,b); 表示在设计中用到一个跟与门（and）一样的名为u1的门，输入端为a，b 输出为q。输出延迟为2个单位时间。要求每个元器件名字是唯一的。
- 用always块 如：

always @ (posedge clk or posedge clr);
begin
          if (clr) q < = 0;
               else if(en) q<= d;
end

6 要点总结
Verilog模块中所有过程块（initial，always）,连续赋值语句，实例引用都是并行的
这三者先后顺序无所谓

7
Verilog HDL 总共有19种数据类型.
最基本的是reg, wire,integer,parameter.
其他数据类ing除time外都与基本逻辑单元建库有关 与系统设计没有很大关系。

8 常量
数字表达式：<width><进制><number>
e.g. 8’b10101010 //位宽为8的数的二进制表示
数字电路中，x代表不定值，z代表高阻值（也可以用'?’）
e.g. 12'dz //位宽为12的十进制数 值为高阻态
负数 只需在位宽表达式前加一个负号 e.g. -8’d5
下划线 可以用来分隔开数的表达式来提高可读性 只能用在具体数字之间 不能用在位宽和进制处  e.g. 16’b1010_1011_1111_1010

9 参数
用parameter来定义常量
e.g. parameter msb = 7, e = 25, f = 29;//定义常数参量

10 wire型变量
常用来表示以assign指定的组合逻辑信号

11 reg型变量
在always模块内被赋值的每一个信号都必须被定义成reg型
(always模块通过使用行为描述语句来表达逻辑关系)

12 memory型
通过对reg型变量建立数组来对存储器建模,可以描述RAM,ROM和reg文件.但是Verilog本身不存在多维数组,因此memory型数据是通过扩展reg型数据的地址范围来生成的.
e.g. reg[7:0] mema[255:0]//定义一个名为mema的存储器,它有256个8位的存储器
e.g. parameter    wordsize = 16;
            memsize = 256;
reg [wordsize-1:0] mem[memsize-1:0],writereg,readreg;//同时定义存储器类型数据和reg型数据

13 算术运算 位运算
进行取模运算时,结果值的符号位采用模运算式里第一个操作数的符号位
e.g. 10%3 = 1 // 余数为1
-10%3 = -1 //结果取第一个操作数的符号位
11%-3 = 2
^按位异或 ~^按位同或
x(不定值)的算术和位运算操作 结果均为x

14等式运算符
==, != 又称为逻辑等式运算符.操作数中某些位为不定值或高阻值,结果也可能为不定值
===, !== 对不定值和高阻值也会进行比较 操作数必须完全一致 结果才为1 常用于case表达式的判别,又称case等式运算符
e.g. if (A == 1’bx) //当A等于x时,后边语句不执行
if(A === 1’bx) //当A等于x时,后边的语句执行

15位拼接运算符
concatenation {} 把两个或多个信号的某些位拼接起来进行运算操作
e.g. {a,b[3:0],w,3’b101}

16 缩减运算符
是对单个操作数进行与或非递推运算,最后的运算结果是1位的2进制数
e.g. reg[3:0] B; reg C;  C = &B
相当于: C = ( (B[0]&B[1]) & B[2] ) & B[3];

17 赋值方式
(1) 非阻塞赋值方式(non-blocking): b <= a;
上面语句所赋的变量值 不能立即就为下面的语句使用
块结束后才能完成这次赋值操作 而所赋的变量值是上一次赋值得到的
编写可综合的时序逻辑模块时 这是最常用的赋值方法
右边的值同时被赋给左边 即原始值
(2) 阻塞赋值方式(blocking): b = a;
赋值语句执行完后 块才结束
b的值在赋值语句执行完成后立刻就改变
在时序逻辑中使用时 可能会产生意想不到的结果
建议：
1. 阻塞式赋值用于组合逻辑建模；
2. 非阻塞式赋值用于时序逻辑建模。

18 块语句
分两种 : (1)begin end语句 表示顺序块 (2)fork join语句  表示并行块
在verilog中 所有变量都是静态的 即所有的变量都只有一个唯一的存储地址 因此进入或跳出块并不影响存储在变量内的值

19 条件语句
必须在过程块语句中使用 过程块语句是指由initial 和 always 语句引导的执行语句集合.除了这两种语句引导的begin end块中可以编写条件语句外 模块中的其他地方均不能
条件语句判断中 0,x,z 都按假处理 1 按真处理

20 分支语句
case(控制表达式)     <case分支项>     endcase
case分支项一般形式：
分支表达式：     语句；
默认项（default):   语句；
case括弧内的表达式称为控制表达式 case分支项中的表达式称为分支表达式
控制表达式通常表示为控制信号的某些位 分支表达式则用这些控制信号的具体状态值来表示 因此分支表达式又可以称为常量表达式

21 循环语句
（1）forever 连续的执行语句
常用于产生周期性的波形，用来作为仿真测试的信号。必须写在initial块中，不像always可以独立
（2）repeat 执行一条语句n次
（3）for （循环语句赋初值; 循环结束条件;循环变量增值）

22 并行块
顺序块和并行块的根本区别在于：当控制转移到块语句的时候，并行块中所有的语句同时开始执行，语句之间的先后顺序是无关紧要的。
可以将并行块的关键字fork看成是将一个执行流分成多个独立的执行流，而关键字join则是将多个独立的执行流合并为一个执行流。

23 命名块
有自己具体名字的块。可以声明局部变量 是设计层次的一部分，命名块中声明的变量可以通过层次名引用进行访问。命名块可以被禁用，例如停止其执行 利用disable关键字

24
Verilog任何过程模块都属于以下4种结构的说明语句
initial说明语句 always说明语句 task说明语句 function说明语句
每个initial always说明语句在仿真的一开始同时立即开始执行。initial语句只执行一次，而always语句则不断重复活动着，直到仿真过程结束。但always后的过程块是否执行 要看他的触发条件是否满足

25 always
always <时序控制> <语句>
如果一个always语句没有时序控制，则这个always语句将会使仿真器产生死锁
e.g. always areg = ~areg;
这个语句将产生一个0延迟的无限循环跳变过程 这时会发生仿真死锁
e.g. always #half_period areg = ~areg;
产生一个周期为：period = ( 2* half_period ) 的无限延续的信号波形

多个信号或事件中任意一个发生的变化都能够触发语句或语句块的执行。由关键词OR 连接的多个事件名或者信号名组成的列表称为敏感列表。或者用“ ，”代替
e.g. always @ ( reset or clock or d );//等待复位信号reset或时钟信号clock或输入信号d改变
e.g. always @ ( posedge areg );//每当areg信号的上升沿出现时

如果组合逻辑块语句的输入变量很多，那么编写敏感列表会很繁琐且容易出错。用@(*)或
@ * 表示对其后面语句块中所有输入变量的变化是敏感的

Verilog同时允许使用另外一种形式表示的电平敏感时序控制，即后面的语句和语句块需要等待某个条件为真才能执行。用wait来表示等待电平敏感的条件为真。
e.g. always
wait （ count_enable )               #20 count = count +1;
//仿真器连续监视count_enable的值，若为0，则继续等待；一旦变为1，则在20个时间单位之后执行这条语句，如果count_enable始终为1，那么count将每过20个时间单位加1.

26 function task
函数的定义不能包含任何时间控制语句，即任何用#，@，或wait来标识得语句
函数不能启动任务
verilog中的函数是不能进行递归调用的。设计模块中若某函数在两个不同的地方被同时并发调用，由于这两个调用同时对同一块地址空间进行操作，那么计算结果将是不确定的。
若在函数声明时使用了关键字automatic，函数就变为自动的或者说可递归的。即仿真器每次函数调用动态的分配新的地址空间，每一个函数调用对各自的地址空间进行操作。

任务可以定义自己的仿真时间单位。任务可以没有或有多个任何类型的输入变量。函数返回一个值，任务则不返回值。

27 $display $write
$display(p1,p2,…,pn);
作用是用来输出信息，即将参数p2到pn按参数p1给定的格式输出，参数p1通常称为格式控制，参数p2至pn常称为输出表列。两个任务作用基本相同，$display自动地在输出后换行，$write不换行

28 系统任务
$fopen(“<文件名>”); 任务返回一个被称为多通道描述符（multichannel descriptor)的32位值, 只有一位被设置成1。
写文件 $fdisplay, $fmonitor, $fwrite 关闭文件$fclose
显示层次 $display, $write, $monitor.当一个模块中的多个实例执行同一段代码时，%m选项会区分那个模块实例在输出
选通显示（Strobing）关键字 $strobe 它可以确保所有在同一时钟沿赋值的其他语句在执行完毕后才显示数据

29 $monitor
当启动一个带有一个或多个参数的$monitor任务时，仿真器建立一个处理机制，使得每当参数列表中变量或表达式的值发生变化时，整个参数列表中变量或表达式的值都将输出显示。参数可以是$time系统函数，这样参数列表中变量或表达式的值的可以实时显示

30 $finish, $stop
$finish作用是退出仿真器， 返回主操作系统，结束仿真过程。
$stop作用是把EDA工具如仿真器，置成暂停模式，在仿真环境下给出一个交互式的命令提示符，将控制权交给用户

31 $random
$random %b；//b>0 它给出了一个范围在（-b+1）：（b-1）中的随机数
{$random} %60；//通过位拼接操作产生一个0~59之间的数

32 `define
`define  signal string // 用标识符 signal来代替string这个字符串
宏名建议使用大写字母 来和变量名相区别
宏定义不是Verilog HDL语句，句尾不用加分号
进行宏定义时，可以引用已定义的宏名，可以层层置换
注释行不会作为被置换的内容

33
文件包含处理`include
时间尺度 `timescale
`timescale <时间单位>/<时间精度>
时间单位参量用于定义模块中仿真时间和延迟时间的基准单位的，时间精度参量用于声明该模块的仿真时间的精确程度。时间精度值不能大于时间单位值
fs = 10^(-15) s
e.g. `timescale 1ns/1ps: 模块中所有时间值都表示是1ns的整数倍。延迟时间可表达为带3位小数的实型数 因为定义的时间精度为1ps

34条件编译
`ifdef, `else, `endif,`elseif，`ifndef(如果没有定义)
`ifdef TEST//若设置TEST标志，则编译后边的语句

35 条件执行
if($test$plusargs(“DISPLAY_VAR"))
     $display(“Display = %b”,{a,b,c});
//只有当标志DISPLAY_VAR设置时才能显示

$value$plusargs用于测试调用选项的参数值，没有找到匹配的调用选项，返回0，否则返回非0

36
wire型:

 wire型数据常用来表示用于以assign关键字指定的组合逻辑信号。Verilog程序模块中输入输出信号类型缺省时自动定义为wire型。wire型信号可以用作任何方程式的输入，也可以用作“assign”语句或实例元件的输出。

wire [n-1:0] 数据名1,数据名2,…数据名i; //共有i条总线，每条总线内有n条线路.或wire [n:1] 数据名1,数据名2,…数据名i;


reg型:

寄存器是数据储存单元的抽象。寄存器数据类型的关键字是reg.通过赋值语句可以改变寄存器储存de值，其作用与改变触发器储存的值相当. 在“always”块内被赋值的每一个信号都必须定义成reg型.

reg [n-1:0] 数据名1,数据名2,… 数据名i;或reg [n:1] 数据名1,数据名2,… 数据名i;

37
在数字电路理论中，时序逻辑电路是指电路任何时刻的稳态输出不仅取决于当前的输入，还与前一时刻输入形成的状态有关。这跟组合逻辑电路相反，组合逻辑的输出只会跟目前的输入成一种函数关系。换句话说，时序逻辑拥有储存元件（内存）来存储信息，而组合逻辑则没有。
除含有组合电路外，时序电路必须含有存储信息的有记忆能力的电路：触发器、寄存器、计数器等。
在数字电路理论中，组合逻辑电路（combinatorial logic或combinational logic）是一种逻辑电路，它的任一时刻的稳态输出，仅仅与该时刻的输入变量的取值有关，而与该时刻以前的输入变量取值无关。这种电路跟时序逻辑电路相反，时序逻辑电路的输出结果是依照目前的输入和先前的输入有关系。从电路结构分析，组合电路由各种逻辑门组成，网络中无记忆元件，也无反馈线。
wire型数据通常用assign语句赋值，reg型数据必须被放在过程语句中（如initial、always）中，通过过程赋值语句赋值。

38
integer 类型可为负数
reg类型不可为复数

39
把行为级的Verilog模块自动转换为门级结构的工具叫综合器（synthesis tool）

40
测试模块 也称作测试文件testbench

在testbench中，可以使用event变量触发事件。

event变量声明为：

event var;

event触发为：

->var;

捕获触发为：

@(var);

41 UDP
User Defined Primitive用户定义的原语 只能描述简单的能用真值表表示的组合或时序逻辑 用primitive 和endprimitive定义

42 Carry look-ahead adder
超前进位加法器

设二进制加法器的第i位输入为Xi, Yi, 输出为Si, 进位输入为Ci，进位输出为Ci+1

则有
         Si = Xi⊕Yi⊕Ci
      Ci+1  = Xi·Yi + Xi·Ci + Yi·Ci = Xi·Yi + (Xi + Yi)·Ci

令Gi = Xi·Yi,     Pi = Xi+Yi

则Ci+1  = Gi + Pi·Ci

当Xi和Yi都为1时，Gi = 1，产生进位Ci+1 = 1

当Xi和Yi有一个为1时，Pi = 1，传递进位Ci+1 = Ci

    因此Gi 定义为进位产生信号，Pi定义为进位传递信号。Gi的优先级比Pi高，也就是说：当Gi = 1时（当然此时也有 Pi = 1 ），无条件产生进位，而不管Ci是多少;

当Gi=0而Pi=1时，进位输出为Ci, 跟Ci之前的逻辑有关。

43
“异步”输入信号指和时钟信号无关，是指输入信号变为有效状态就器件的状态就改变，“同步”输入信号和时钟信号有关，实际上输入信号和时钟信号进行了与运算或者与非运算，输入信号和时钟信号的运算结果是有效的器件的状态才会改变。
同步信号可以过滤掉不正确状态跳变对逻辑的影响，但是需要保证有效输入信号在时钟信号跳变钱完成跳变，否则输入信号就是无效的。异步信号则和同步信号的效果正好相反。使用时请根据实际情况考虑。
